Yet another I2C (really TWI) bridge/controller/interface
Larry Doolittle, LBNL, August 2018

Primary goals:
  - When the FPGA boots, this module should be able to send a batch of
configuration writes to one or more I2C busses, without external help.
  - After boot, it should go into a polling loop, reading out status
and making it available via a convenient dual-port-memory interface to
a host (local or network-based).
  - A host (local or network-based) should be able to modify existing or
create new command strings to send to the I2C busses.
  - Collect bus activity traces to let people diagnose bus behavior
  - Be small enough to be ignored in the resource accounting of an SoC

Workstation requirements:  standard *nix tools, Icarus Verilog, gtkwave,
GhostScript.  At some point you'll also need chip-specific synthesis,
place, and route for the full chip that will instantiate this module.

Abstract design: use a dual-port RAM (one quantum in 7-series is 4K x 8)
to hold:
  an instruction sequence, including data for I2C write commands
  results of I2C read commands
  output trace from an embedded logic analyzer

Most of the above features are done and tested in simulation.
To exercise some simple regression tests, just do "make".
To exercise the logic-analyzer part, "make a2trace_view".
Makefile targets can also give you waveform views of the internal states:
i2c_bit_view, i2c_prog_view, i2c_analyze_view, and i2c_chunk_view.

A simplified block diagram is in blocks.eps.  It is annotated, to possibly
be useful as a top-level introduction to the code.  To edit that file, use
xcircuit.  If you'd rather look at it as a PDF, "make blocks.pdf".

Current synthesis result in Spartan-6 using ISE 14.7:
  203 LUT/FF pairs and 2 x 16K BRAM, 200 MHz

Instruction encoding:
 3-bits opcode
 5-bits numeric parameter n
opcode
 000  oo   special
 001  rd   read
 010  wr   write
 011  wx   write followed by repeated start
 100  p1   pause (ticks are 8 bit times)
 101  p2   pause (ticks are 256 bit times)
 110  jp   jump
 111  sx   set result address
specials
 000 00000  zz  sleep
 000 00010  bf  result buffer flip
 000 00011  ta  trigger logic analyzer
 000 1xxxx  hw  hardware bus select/configure (includes reset?)
The jump command jumps to the address constructed as {n, 5'b0}, thus can
reach the whole 10-bit address space reach with granularity of 32 bytes.

wr and wx instructions are followed by n words of data.
A rd instruction is followed by only 1 data word (the device address);
the remaining n-1 words are all sent as high bits on the i2c bus, allowing
the data coming back from the slave to be read and posted to result memory.

The alert Makefile reader will observe that the instruction sequence fed to
the test bench is created by a python program, ramtest.py.  This program
includes a built-in assembler that encapsulates the instruction encoding
shown above.

Other notes:
  The I2C czars would be unhappy that this code doesn't handle clock
stretching or multi-mastering.  So officially this should be called TWI
(two-wire interface) instead.  But it's intended for use with commonly
available I2C peripherals, including SFP modules, and none of the chips
I've encountered actually use those features.
  The dpram.v code is not identical to that in LBNL's code repo.
It is superficially compatible, but will require more testing.

To do:
  Write more documentation
  Add more features to i2c_prog: skip if interrupt
  Add more features to analyzer: commands, reset, interrupt
  More host control and status?
  Synthesis-time setup of RAM contents
  Test on hardware (VC707? Marble-Mini?)
  Wishbone bridge?
  Add meta-control path?

See design.txt for a longer story.
