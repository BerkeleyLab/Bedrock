# Marble1

Initial programming support for
[Marble Mini](https://github.com/BerkeleyLab/Marble-Mini)
and [Marble](https://github.com/BerkeleyLab/Marble) hardware.
The Marble.xdc file here is the one generated by a script in that repository.

Infrastructure provided by [Bedrock](https://github.com/BerkeleyLab/Bedrock).

Currently tested successful at booting a bitfile (using [openocd](https://openocd.org/)),
bringing up Ethernet (synthesized default IP address 192.168.19.10,
but that's normally overridden by the on-board MMC), blinking LEDs,
and reading/writing/booting SPI Flash (using Bedrock's spi_test.py).
There's a trivial utility (mutil) that documents common operations,
and [instructions](bringup.txt) for initial FPGA/Flash programming.
Also see the [todo list](todo).

Top-level needs more automated regression testing.  Concept for testing in simulation:

    make net_slave_run &
    python testcase.py --sim --ramtest --stop
    make lb_marble_slave_view

Hardware tests of the I2C subsystem (bedrock's i2cbridge gateware)
will configure and read out SFPs, read the write-protect status, FMC voltage and current, and blink LEDs:

    ./mutil usb
    python testcase.py --sfp --vcd=capture.vcd
    gtkwave capture.vcd
    python testcase.py --sfp --poll --rlen=64

Periodic output from that last step is something like:

    Write Protect switch is Off
    FMC1:  current  0.000 A   voltage  10.399 V
    FMC2:  current  0.119 A   voltage  10.399 V
    SFP1:  0xF
    SFP2:  0xB
      Temp     35.0 C
      Vcc      3.248 V
      Tx bias  0.0000 mA
      Tx pwr   0.0001 mW
      Rx pwr   0.0001 mW
    SFP3:  0xF
    SFP4:  0xF

Also see [testcase.py](testcase.py) for other I2C feature support,
some of which is specific to either Marble or Marble-Mini.

## Extras

Two [Easter eggs](https://en.wikipedia.org/wiki/Easter%20egg%20%28media%29):

1. Connect up a user terminal to the third FTDI USB UART port, typically /dev/ttyUSB2,
at 9600 baud and you'll get a continuous readout of on-board frequencies:
```
    Channel 0:  124.99998 MHz
    Channel 1:  019.99654 MHz
    Channel 2:  125.00003 MHz
    Channel 3:  068.54776 MHz
```
    Channel 0 is the Ethernet Rx clock from the switch,
    Channel 1 is the on-board 20 MHz VCXO,
    Channel 2 is the on-board Si570 (Marble-only), and
    Channel 3 is the FPGA's internal configuration oscillator

Frequencies above use the on-board 125 MHz clock as a reference.
This output can be really helpful diagnostics: success indicates
all of power, bitfile loaded, USB functioning, and 125 MHz clock
present, independent of Ethernet and microcontroller.


2. Attach a [Digilent Pmod](https://digilent.com/reference/pmod/start) GPS
to the top half of J13 (a.k.a. Pmod2[3:0]), and you can
read out [NMEA](https://en.wikipedia.org/wiki/NMEA_0183) position and time,
use the pps signal to calibrate the on-board crystals,
and even phase-lock the on-board 125 MHz source to GPS time
with an additive jitter as little as 10 ns rms.
Supporting python:

* [nmea_view.py](nmea_view.py)
* [scan_vcxo.py](scan_vcxo.py)
* [lock_vcxo.py](lock_vcxo.py)
