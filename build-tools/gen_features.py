import sys
import os
import argparse
import yaml
import json


def parse_yaml(fname, config=False, verbose=False):
    with open(fname, 'r') as FH:
        try:
            yy = yaml.load(FH, Loader=yaml.FullLoader)
        except yaml.YAMLError as e:
            print("Badly formatted yaml file: %s" % fname)
            print(e)
            sys.exit(-1)

    config_list = [k for k in yy.keys() if not k.startswith("__")]

    if not config:
        if verbose:
            print("No config specified, parsing all configs specified in %s" % fname)
    else:
        if config in config_list:
            config_list = [config]
            if verbose:
                print("Parsing config %s" % config)
        else:
            print("WARNING: Specified config %s does not exist in %s. Parsing all configs." % (config, fname))

    config_dicts = [(k, yy[k]) for k in config_list]

    return config_dicts


def write_json(basename, cfg_dict, verbose=False):
    fname = basename + ".json"
    if verbose:
        print("Writing metadata to JSON: %s" % fname)

    # Extract parameters from configuration dict and wrap in metadata dict
    p_dict = cfg_dict['params']
    m_dict = {"__metadata__": p_dict}

    with open(fname, 'w') as FH:
        json.dump(m_dict, FH, sort_keys=True, indent=4, separators=(',', ': '))


def write_vlog(basename, cfg_dict, split=False, verbose=False):
    fname = basename + ".vh"
    fname_params = basename + "_params" + ".vh"
    fname_defs = basename + "_defs" + ".vh"

    if verbose:
        print("Writing parameters to Verilog: %s" % fname)
        if split:
            print("Writing parameters to Verilog: %s and %s" % (fname_defs, fname_params))

    # Separate parameters from defines
    p_dict = cfg_dict['params']
    d_dict = cfg_dict['defs']

    p_string = "localparam C_%s = %s;\n\n"  # prefix parameters to avoid namespace clashes
    d_string = "`define %s\n\n"

    if split:
        FP = open(fname_params, 'w')
        FD = open(fname_defs, 'w')
        Fs = [FP, FD]
    else:
        FP = open(fname, 'w')
        FD = FP  # Alias FP to FD so the params/defs writing code below is generic
        Fs = [FP]

    for f in Fs:
        f.write("// Machine generated by gen_features.py\n\n")

    for p, v in p_dict.items():
        if type(v) is str:
            v = '\"%s\"' % v
        FP.write(p_string % (p.upper(), v))

    # Use include guard for defines only
    FD.write("`ifndef __%(n)s__\n`define __%(n)s__\n\n" % {'n': basename.upper()})
    for d, v in d_dict.items():
        if v == 0:
            FD.write("//")
        FD.write(d_string % d.upper())
    FD.write("\n`endif // __%s__\n" % basename.upper())


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Parses a feature definition YAML containing per-config\
                                                  defines/parameter. The output are per-config ROM metadata\
                                                  in JSON format and Verilog packages')
    parser.add_argument('-i', '--input', type=str, required=True, help='A list of json files to be merged')
    parser.add_argument('-c', '--config', default=False, type=str,
                        help='Configuration to generate JSON and VH files for. Default is all configs')
    parser.add_argument('-s', '--split', action='store_true', help='Splits defines and parameters into separate\
                                                                    header files')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    args = parser.parse_args()

    cfg_dicts = parse_yaml(args.input, args.config, args.verbose)

    # Derive basename from YAML
    basename = os.path.splitext(os.path.basename(args.input))[0]

    # If generating more than one config append config name
    cfg_append = True if len(cfg_dicts) > 1 else False

    for cfg in cfg_dicts:
        fname = basename
        if cfg_append:
            fname = fname + '_' + cfg[0]
        write_json(fname, cfg[1], args.verbose)
        write_vlog(fname, cfg[1], args.split, args.verbose)
